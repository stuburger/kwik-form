/*! For license information please see a9bc01a8.4e03b2f0.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{129:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return u})),t.d(n,"rightToc",(function(){return m})),t.d(n,"default",(function(){return p}));var a=t(2),r=t(6),i=(t(0),t(146)),o=t(156),l=t(154),s={id:"validation",title:"Validating user input",sidebar_label:"Validation"},u={id:"validation",title:"Validating user input",description:"Validation in Yafl is opinionated but straight forward and is usually done at the field-level. Most form libraries provide form-level validation as a means to give access to the entire form's values by way of a validate prop on the Form component. That's great, but Yafl gives you access to the form value at the field-level, so form-level validation becomes somewhat redundant. Futhermore there are some benefits to favouring field-level validation:",source:"@site/docs/validation.md",permalink:"/yafl/docs/validation",sidebar_label:"Validation",sidebar:"main",previous:{title:"Tutorial",permalink:"/yafl/docs/tutorial"},next:{title:"Arrays and nested objects",permalink:"/yafl/docs/arrays-and-objects"}},m=[{value:"Field-level validation",id:"field-level-validation",children:[{value:"Field validators",id:"field-validators",children:[]}]},{value:"Form-level validation",id:"form-level-validation",children:[{value:"useBranchValues to grab errors",id:"usebranchvalues-to-grab-errors",children:[]}]},{value:"Async validation",id:"async-validation",children:[{value:"Using a <code>&lt;FormError /&gt;</code>",id:"using-a-formerror-",children:[]}]},{value:"Validation FAQ",id:"validation-faq",children:[{value:"Can I manually trigger validation?",id:"can-i-manually-trigger-validation",children:[]},{value:"What about submission phases?",id:"what-about-submission-phases",children:[]}]},{value:"Validation gotchas",id:"validation-gotchas",children:[]}],c={rightToc:m};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Validation in Yafl is opinionated but straight forward and is usually done at the field-level. Most form libraries provide form-level validation as a means to give access to the entire form's values by way of a ",Object(i.b)("inlineCode",{parentName:"p"},"validate")," prop on the Form component. That's great, but Yafl gives you access to the form value at the field-level, so form-level validation becomes somewhat redundant. Futhermore there are some benefits to favouring field-level validation:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Validation logic is always co-located with the field that it's validating. This means when you delete a field, for example, you are only removing code from one place and not two."),Object(i.b)("li",{parentName:"ol"},"Easier to reason about and easier to debug form validation."),Object(i.b)("li",{parentName:"ol"},"Easier to compose and share field validation logic by making use of individual field validators."),Object(i.b)("li",{parentName:"ol"},"Semantically it makes more sense to validate a field on its own. Whether a form is valid or not is a function of the validity of its fields only.")),Object(i.b)("p",null,"That isn't to say yafl doesn't support form-level validation - Yafl provides you with the primitives that allow you to enable form-level validation using a library like Yup. More on that in a bit, but first let's learn how to do field-level validation."),Object(i.b)("h2",{id:"field-level-validation"},"Field-level validation"),Object(i.b)("p",null,"Let's enable field-level validation in our ",Object(i.b)("inlineCode",{parentName:"p"},"TextInput")," component:"),Object(i.b)(o.a,{defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="/src/TextInput.js"',title:'"/src/TextInput.js"'}),"import { useField } from 'yafl'\n\nfunction TextInput(props) {\n  const { name, label, type, validate } = props\n  const [input, meta] = useField(name, { validate });\n  const { isValid, touched, submitCount, errors = [] } = meta;\n  const showError = !isValid && (touched || submitCount > 0);\n\n  return (\n    <>\n      <label htmlFor={name}>{label}</label>\n      <input name={name} type={type} {...input} />\n      {showError && <div>{errors[0]}</div>}\n    </>\n  );\n}\n\nexport default TextInput\n"))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts",metastring:'title="/src/TextInput.tsx"',title:'"/src/TextInput.tsx"'}),"import { useField, FieldValidator } from 'yafl'\n\ninterface TextInputProps<T, F extends object> {\n  name: string;\n  label: string;\n  type?: string;\n  validate?: FieldValidator<T, F> | Array<FieldValidator<T, F>>\n}\n\nfunction TextInput<T, F extends object = {}>(props: TextInputProps<T, F>) {\n  const { name, label, type = 'text', validate } = props\n  const [input, meta] = useField<T, F>(name, { validate });\n  const { isValid, touched, submitCount, errors = [] } = meta;\n  const showError = !isValid && (touched || submitCount > 0);\n\n  return (\n    <>\n      <label htmlFor={name}>{label}</label>\n      <input name={name} type={type} {...input} />\n      {showError && <div>{errors[0]}</div>}\n    </>\n  );\n}\n\nexport default TextInput\n")))),Object(i.b)("p",null,"There are a couple of things to take note of here. The first thing to pay attention to is the addition of the ",Object(i.b)("inlineCode",{parentName:"p"},"validate")," prop that is then supplied to ",Object(i.b)("inlineCode",{parentName:"p"},"useField"),"'s config options. ",Object(i.b)("inlineCode",{parentName:"p"},"validate")," is a function or array of functions that are executed every time the ",Object(i.b)("inlineCode",{parentName:"p"},"value")," for this field changes - regardless of how or when the field changes*."),Object(i.b)("p",null,"What else is there? For one thing you can see that we are now making use of the second value in the tuple returned from ",Object(i.b)("inlineCode",{parentName:"p"},"useField"),". This ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," value contains meta information about the field. This is then being used to decide when to display field errors. "),Object(i.b)("p",null,"In this particular case we're saying, only show errors when:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the field is in fact ",Object(i.b)("em",{parentName:"li"},"invalid")," (",Object(i.b)("inlineCode",{parentName:"li"},"isValid = errors.length === 0"),") and,"),Object(i.b)("li",{parentName:"ul"},"the field has been ",Object(i.b)("inlineCode",{parentName:"li"},"touched")," or,"),Object(i.b)("li",{parentName:"ul"},"the form has been submitted at least once")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"*"," ",Object(i.b)("strong",{parentName:"p"},"Note:"),"\nThat's right, validation errors in Yafl are derived any time a field's value changes. Field errors, and by extension form errors, are determined by simply looking at the values of a field and running them through a validation function or set of validation functions. In other words, there is no such thing as (and no need for) a ",Object(i.b)("inlineCode",{parentName:"p"},"validateOnBlur")," or ",Object(i.b)("inlineCode",{parentName:"p"},"validateOnChange")," prop in Yafl. Validation is declarative and validity is described only by the current values that the form holds. "),Object(i.b)("p",{parentName:"blockquote"},"It is up to you to decide when to display these errors based on the metadata of your form. For example you might display errors for a field based on whether a field is ",Object(i.b)("inlineCode",{parentName:"p"},"touched")," or not, or perhaps a little later on in the user's workflow - for example, once the user has attempted form submission.")),Object(i.b)("h3",{id:"field-validators"},"Field validators"),Object(i.b)("p",null,"Now we can supply the validation functions to our ",Object(i.b)("inlineCode",{parentName:"p"},"TextInput"),"s from the ",Object(i.b)("inlineCode",{parentName:"p"},"SignupForm")," component by way of the ",Object(i.b)("inlineCode",{parentName:"p"},"validate")," prop:"),Object(i.b)(o.a,{defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="/src/SignupForm.js"',title:'"/src/SignupForm.js"'}),"import React from 'react'\nimport { Form } from 'yafl'\nimport TextInput from './TextInput'\n\nconst initialValue = {\n  email: '',\n  password: '',\n  confirmPassword: ''\n}\n\nfunction SignupForm(props) {\n  function handleSubmit(value) {\n    console.log(value)\n  }\n\n  return (\n    <Form\n      initialValue={initialValue} \n      onSubmit={handleSubmit}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput \n            name=\"email\"\n            validate={(email) => {\n              if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(email)) {\n                return 'Email is not valid'\n              }\n            }}\n          />\n          <TextInput \n            name=\"password\" \n            type=\"password\"\n            validate={(password) => {\n              if (password.length < 8) {\n                return 'Password too short'\n              }\n            }}\n          />\n          <TextInput \n            name=\"confirmPassword\"\n            type=\"password\"\n            validate={(password, formValue) => {\n              if (password !== formValue.confirmPassword) {\n                return 'Passwords do not match'\n              }\n            }}\n          />\n          <button type=\"submit\">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n\n"))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts",metastring:'title="/src/SignupForm.tsx"',title:'"/src/SignupForm.tsx"'}),"import React from 'react'\nimport { Form } from 'yafl'\nimport TextInput from './TextInput'\n\ninterface FormValue {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\nconst initialValue: FormValue = {\n  email: '',\n  password: '',\n  confirmPassword: ''\n}\n\nfunction SignupForm(props: {}) {\n  function handleSubmit(value: FormValue) {\n    console.log(value)\n  }\n\n  return (\n    <Form<FormValue> \n      initialValue={initialValue} \n      onSubmit={handleSubmit}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput<string> \n            name=\"email\"\n            validate={(email) => {\n              if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(email)) {\n                return 'Email is not valid'\n              }\n            }}\n          />\n          <TextInput<string> \n            name=\"password\" \n            type=\"password\"\n            validate={(password) => {\n              if (password.length < 8) {\n                return 'Password too short'\n              }\n            }}\n          />\n          <TextInput<string, FormValue> \n            name=\"confirmPassword\" \n            type=\"password\"\n            validate={(password, formValue) => {\n              if (password !== formValue.confirmPassword) {\n                return 'Passwords do not match'\n              }\n            }}\n          />\n          <button type=\"submit\">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n")))),Object(i.b)("p",null,"This should be all that is needed to enable field-level validation. Notice that in each case we are only supplying a single validation function to each ",Object(i.b)("inlineCode",{parentName:"p"},"TextInput")," but note that this could also be an array of validation functions. While this is done inline for illustrative purposes it is easy to pull them out into their own reusable functions to be consumed by any forms across your app. A validator should return a ",Object(i.b)("inlineCode",{parentName:"p"},"string")," representing the error message to be displayed to your user when the field is invalid and ",Object(i.b)("inlineCode",{parentName:"p"},"undefined")," if it is valid."),Object(i.b)("h2",{id:"form-level-validation"},"Form-level validation"),Object(i.b)("p",null,"While field-level validation is the approach we recommend, Yafl is flexible enough to shoehorn a form-level validation implementation into your app. Let's take a look at how it can be done using Yup:"),Object(i.b)(o.a,{defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="/src/SignupForm.js"',title:'"/src/SignupForm.js"'}),'import React from \'react\'\nimport { Form } from \'yafl\'\nimport * as yup from \'yup\'\nimport set from \'lodash.set\'\nimport TextInput from \'./TextInput\'\n\nconst schema = yup.object({\n  email: yup\n    .string()\n    .email()\n  password: yup\n    .string()\n    .required("Password is required")\n    .min(8),\n  confirmPassword: yup\n    .string()\n    .when("password", {\n      is: val => val && val.length > 0,\n      then: yup\n        .string()\n        .oneOf([yup.ref("password")], "Both passwords need to be the same")\n        .required()\n  }\n});\n\nfunction validate(value) {\n  try {\n    schema.validateSync(value, { abortEarly: false });\n    // if all goes well return an empty error object\n    return {};\n  } catch (errors) {\n    // otherwise catch and extract errors\n    const { inner } = errors;\n    return inner.reduce((ret, x) => set(ret, x.path, x.message), {});\n  }\n};\n\nconst initialValue = {\n  email: \'\',\n  password: \'\',\n  confirmPassword: \'\'\n}\n\nfunction SignupForm(props) {\n  function handleSubmit(value) {\n    console.log(value)\n  }\n\n  return (\n    <Form\n      initialValue={initialValue} \n      onSubmit={handleSubmit}\n      branchValues={({ formValue }) => ({ error: validate(formValue) })}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput name="email" />\n          <TextInput name="password" type="password" />\n          <TextInput name="confirmPassword" type="password" />\n          <button type="submit">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts",metastring:'title="/src/SignupForm.tsx"',title:'"/src/SignupForm.tsx"'}),'import React from \'react\'\nimport { Form } from \'yafl\'\nimport * as yup from \'yup\'\nimport set from \'lodash.set\'\nimport TextInput from \'./TextInput\'\n\ninterface FormValue {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\nconst schema = yup.object({\n  email: yup\n    .string()\n    .email()\n  password: yup\n    .string()\n    .required("Password is required")\n    .min(8),\n  confirmPassword: yup\n    .string()\n    .when("password", {\n      is: val => val && val.length > 0,\n      then: yup\n        .string()\n        .oneOf([yup.ref("password")], "Both passwords need to be the same")\n        .required()\n  }\n});\n\nfunction yupValidate(value: FormValue) {\n  try {\n    schema.validateSync(value, { abortEarly: false });\n    // if all goes well return empty error object\n    return {};\n  } catch (errors) {\n    // otherwise catch and extract errors\n    const { inner } = errors;\n    return inner.reduce((ret, x) => set(ret, x.path, x.message), {});\n  }\n};\n\nconst initialValue: FormValue = {\n  email: \'\',\n  password: \'\',\n  confirmPassword: \'\'\n}\n\nfunction SignupForm(props: {}) {\n  function handleSubmit(value: FormValue) {\n    console.log(value)\n  }\n\n  return (\n    <Form<FormValue> \n      initialValue={initialValue} \n      onSubmit={handleSubmit}\n      branchValues={({ formValue }) => ({ error: validate(formValue) })}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput<string> name="email" />\n          <TextInput<string> name="password" type="password" />\n          <TextInput<string> name="confirmPassword" type="password" />\n          <button type="submit">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n')))),Object(i.b)("p",null,"There is a lot to unpack here so lets go through it bit by bit. Firstly, notice that there is no ",Object(i.b)("inlineCode",{parentName:"p"},"validate")," function on the ",Object(i.b)("inlineCode",{parentName:"p"},"TextInput")," anymore. All validation is now done using Yup. We are effectively opting out of Yafl's internal implementation for form validation and we've replaced it entirely with something else. "),Object(i.b)("p",null,"Next, notice that there is a new Form prop in play and is curiously named ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues"),". ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues"),' represents one of two possible mechanisms with which Yafl can distribute or "deliver" values to your fields. You can read more about the ',Object(i.b)("inlineCode",{parentName:"p"},"branchValues")," prop and its corresponding hook, ",Object(i.b)("inlineCode",{parentName:"p"},"useBranchValues")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./usebranchvalues"}),"here")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./form#branchvalues"}),"here"),". But in a nutshell, ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues")," will intelligently split an object's values and distribute them to the fields with the paths that match the locations of the values of the object supplied."),Object(i.b)("p",null,"The rest is really just implementation detail - the new ",Object(i.b)("inlineCode",{parentName:"p"},"validate()")," function is simply there to run our ",Object(i.b)("inlineCode",{parentName:"p"},"formValue")," through Yup and then transform these errors into a format that enables delivery to your fields."),Object(i.b)("p",null,"But this is only half the story, next let's see how we would have to adapt our ",Object(i.b)("inlineCode",{parentName:"p"},"TextInput")," to receive and correctly work with these errors."),Object(i.b)("h3",{id:"usebranchvalues-to-grab-errors"},"useBranchValues to grab errors"),Object(i.b)(o.a,{defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="/src/TextInput.js"',title:'"/src/TextInput.js"'}),"import { useField, useBranchValues } from 'yafl'\n\nfunction TextInput(props) {\n  const { name, label, type = 'text' } = props\n  const [input, meta] = useField(name);\n  const { error } = useBranchValues(name)\n\n  const { touched, submitCount } = meta;\n  const showError = !!error && (touched || submitCount > 0);\n\n  return (\n    <>\n      <label htmlFor={name}>{label}</label>\n      <input name={name} type={type} {...input} />\n      {showError && <div>{errors[0]}</div>}\n    </>\n  );\n}\n\nexport default TextInput\n"))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts",metastring:'title="/src/TextInput.tsx"',title:'"/src/TextInput.tsx"'}),"import { useField, useBranchValues } from 'yafl'\n\ninterface TextInputProps<T, F extends object> {\n  name: string;\n  label: string;\n  type?: string;\n}\n\nfunction TextInput<T, F extends object = {}>(props: TextInputProps<T, F>) {\n  const { name, label, type = 'text' } = props\n  const [input, meta] = useField<T, F>(name);\n  const { error } = useBranchValues<{ error: string }>(name)\n\n  const { touched, submitCount } = meta;\n  const showError = !!error && (touched || submitCount > 0);\n\n  return (\n    <>\n      <label htmlFor={name}>{label}</label>\n      <input name={name} type={type} {...input} />\n      {showError && <div>{errors[0]}</div>}\n    </>\n  );\n}\n\nexport default TextInput\n")))),Object(i.b)("p",null,"The most noteworthy change here is the addition of the ",Object(i.b)("inlineCode",{parentName:"p"},"useBranchValues")," hook to grab the error for this field. Note that this value is simply a ",Object(i.b)("inlineCode",{parentName:"p"},"string")," and not a ",Object(i.b)("inlineCode",{parentName:"p"},"string[]"),". Again, this is an implementation detail and it's up to you whether you feel it's necessary to supply an array errors or a single error message to your fields."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"Note:"),"\n",Object(i.b)("inlineCode",{parentName:"p"},"meta.errors")," will simply contain be an empty array since you will have opted out of Yafl's error handling implementation.")),Object(i.b)("h2",{id:"async-validation"},"Async validation"),Object(i.b)("p",null,"And then there is the elephant in the room: async validation. Let's say the requirement came in to enable asynchronously checking if a username or email address was available before the user attempted to submit the form. This would require calling some backend api to check if the email is available."),Object(i.b)("p",null,"So how does yafl handle this async validation? As with form-level validation, Yafl does not support async validation out of the box, but provides two mechanisms that effectively enable it. "),Object(i.b)("p",null,"The first option is to use the same ",Object(i.b)("inlineCode",{parentName:"p"},"useBranchValues")," or ",Object(i.b)("inlineCode",{parentName:"p"},"useCommonValues")," mechanism as with the above with Yup example above. "),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"Note:"),"\nRemember that you can supply multiple values to ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues")," that will then be delivered to your fields so you can use Yup and still supply any number of other arbitrary values to ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues"))),Object(i.b)("p",null,'The second and preferred way to "enable" async validation is by rendering a ',Object(i.b)("inlineCode",{parentName:"p"},"<FormError />")," with a string ",Object(i.b)("inlineCode",{parentName:"p"},"path")," to the field that the error belongs to along with a ",Object(i.b)("inlineCode",{parentName:"p"},"msg")," representing the error as soon as we get a response from the server. This error ",Object(i.b)("inlineCode",{parentName:"p"},"msg")," will be concatenated onto that field's ",Object(i.b)("inlineCode",{parentName:"p"},"errors")," array. "),Object(i.b)("h3",{id:"using-a-formerror-"},"Using a ",Object(i.b)("inlineCode",{parentName:"h3"},"<FormError />")),Object(i.b)("p",null,"Since we've already covered ",Object(i.b)("inlineCode",{parentName:"p"},"branchValues")," and ",Object(i.b)("inlineCode",{parentName:"p"},"useBranchValues")," as a method of value distribution let's look how to accomplish async validation by rendering a ",Object(i.b)("inlineCode",{parentName:"p"},"<FormError />"),":"),Object(i.b)(o.a,{defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="/src/SignupForm.js"',title:'"/src/SignupForm.js"'}),'import React, { useState } from \'react\'\nimport { Form, FormError } from \'yafl\'\nimport TextInput from \'./TextInput\'\n\nconst initialValue = {\n  email: \'\',\n  password: \'\',\n  confirmPassword: \'\'\n}\n\nfunction SignupForm(props) {\n  const { checkEmailAvailability } = props\n\n  const [emailAvailable, setEmailAvailability] = useState(true)\n\n  function handleSubmit(value) {\n    console.log(value)\n  }\n\n  async function checkEmail(email) {\n    const isAvailable = await checkEmailAvailability(email)\n    setEmailAvailability(isAvailable)\n  }\n\n  function onFormValueChange(prev, next) {\n    if(next.email && prev.email !== next.email) {\n      checkEmail(next.email)\n    }\n  }\n\n  return (\n    <Form\n      initialValue={initialValue}\n      onSubmit={handleSubmit}\n      onFormValueChange={onFormValueChange}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput name="email" />\n          <TextInput name="password" type="password" />\n          <TextInput name="confirmPassword" type="password" />\n          {emailAvailable && <FormError path="email" msg="Email already in use!">}\n          <button type="submit">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts",metastring:'title="/src/SignupForm.tsx"',title:'"/src/SignupForm.tsx"'}),'import React, { useState } from \'react\'\nimport { Form, FormError } from \'yafl\'\nimport TextInput from \'./TextInput\'\n\ninterface FormValue {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface SignupFormProps {\n  checkEmailAvailability: (email: string) => Promise<boolean>\n}\n\nconst initialValue: FormValue = {\n  email: \'\',\n  password: \'\',\n  confirmPassword: \'\'\n}\n\nfunction SignupForm(props: SignupFormProps) {\n  const { checkEmailAvailability } = props\n\n  const [emailAvailable, setEmailAvailability] = useState(true)\n\n  function handleSubmit(value: FormValue) {\n    console.log(value)\n  }\n\n  async function checkEmail(email: string) {\n    const isAvailable = await checkEmailAvailability(email)\n    setEmailAvailability(isAvailable)\n  }\n\n  function onFormValueChange(prev: FormValue, next: FormValue) {\n    if(next.email && prev.email !== next.email) {\n      checkEmail(next.email)\n    }\n  }\n  return (\n    <Form<FormValue> \n      initialValue={initialValue} \n      onSubmit={handleSubmit}\n      onFormValueChange={onFormValueChange}\n    >\n      {(yafl) => (\n        <form onSubmit={yafl.submit}>\n          <TextInput<string> name="email" />\n          <TextInput<string> name="password" type="password" />\n          <TextInput<string> name="confirmPassword" type="password" />\n          {emailAvailable && <FormError path="email" msg="Email already in use!">}\n          <button type="submit">Sign up!<button>\n        </form>\n      )}\n    </Form>\n  )\n}\n')))),Object(i.b)("p",null,"Once a ",Object(i.b)("inlineCode",{parentName:"p"},"<FormError />")," mounts the ",Object(i.b)("inlineCode",{parentName:"p"},"msg")," representing the form error will be concatenated onto ",Object(i.b)("inlineCode",{parentName:"p"},"meta.errors"),". When the ",Object(i.b)("inlineCode",{parentName:"p"},"<FormError />")," unmounts, it will be removed. Note that the following code would be equivalent:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),' <FormError path="email" msg={emailAvailable ? undefined : "Email already in use!"}>\n')),Object(i.b)("h2",{id:"validation-faq"},"Validation FAQ"),Object(i.b)("h3",{id:"can-i-manually-trigger-validation"},"Can I manually trigger validation?"),Object(i.b)("p",null,"Nope. Yafl does not allow you to manually trigger validation this is because error states are derived from form values automatically. While Yafl does technically store error state, you should not let this is implementation detail detract from the fact that form errors are a textbook example of derived state. Yafl gives you full control over when to show errors to your users."),Object(i.b)("h3",{id:"what-about-submission-phases"},"What about submission phases?"),Object(i.b)("p",null,"There is no such thing in Yafl. Validation is happening all the time - or at least any time a values changes. Yafl also does not rely on any magic to make validation work - like touching all fields on submission. This means there is on need to keep track of ",Object(i.b)("inlineCode",{parentName:"p"},"isValidating")," or to do ",Object(i.b)("inlineCode",{parentName:"p"},"setSubmitting(false)"),". "),Object(i.b)("p",null,"Since you, the developer, are best positioned to know when the form is validating (in the case of asynchronous validation) and when the from is submitting and it is Yafl's opinion that this behavior is implemented in Userland."),Object(i.b)("h2",{id:"validation-gotchas"},"Validation gotchas"),Object(i.b)("p",null,"Yafl tries very hard to avoid gotchas that increase cognitive load, but there is one around validation to be aware of - validation errors are assumed to be unique per field. Yafl will remove de-dupe error messages if they occur multiple times for an individual field. However this is a fairly edge casey requirement, but it is something to be aware of!"))}p.isMDXComponent=!0},146:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return b}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=r.a.createContext({}),m=function(e){var n=r.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=m(e.components);return r.a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=m(t),d=a,b=c["".concat(o,".").concat(d)]||c[d]||p[d]||i;return t?r.a.createElement(b,l(l({ref:n},u),{},{components:t})):r.a.createElement(b,l({ref:n},u))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=t[u];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},147:function(e,n,t){var a;!function(){"use strict";var t={}.hasOwnProperty;function r(){for(var e=[],n=0;n<arguments.length;n++){var a=arguments[n];if(a){var i=typeof a;if("string"===i||"number"===i)e.push(a);else if(Array.isArray(a)&&a.length){var o=r.apply(null,a);o&&e.push(o)}else if("object"===i)for(var l in a)t.call(a,l)&&a[l]&&e.push(l)}}return e.join(" ")}e.exports?(r.default=r,e.exports=r):void 0===(a=function(){return r}.apply(n,[]))||(e.exports=a)}()},152:function(e,n,t){"use strict";var a=t(0);const r=Object(a.createContext)({tabGroupChoices:{},setTabGroupChoices:()=>{}});n.a=r},154:function(e,n,t){"use strict";var a=t(0),r=t.n(a);n.a=function(e){return r.a.createElement("div",null,e.children)}},156:function(e,n,t){"use strict";var a=t(0),r=t.n(a),i=t(152);var o=function(){return Object(a.useContext)(i.a)},l=t(147),s=t.n(l),u=t(92),m=t.n(u);const c=37,p=39;n.a=function(e){const{block:n,children:t,defaultValue:i,values:l,groupId:u}=e,{tabGroupChoices:d,setTabGroupChoices:b}=o(),[h,f]=Object(a.useState)(i);if(null!=u){const e=d[u];null!=e&&e!==h&&f(e)}const v=e=>{f(e),null!=u&&b(u,e)},y=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:s()("tabs",{"tabs--block":n})},l.map(({value:e,label:n})=>r.a.createElement("li",{role:"tab",tabIndex:"0","aria-selected":h===e,className:s()("tabs__item",m.a.tabItem,{"tabs__item--active":h===e}),key:e,ref:e=>y.push(e),onKeyDown:e=>((e,n,t)=>{switch(t.keyCode){case p:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case c:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(y,e.target,e),onFocus:()=>v(e),onClick:()=>v(e)},n))),r.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},a.Children.toArray(t).filter(e=>e.props.value===h)[0]))}}}]);