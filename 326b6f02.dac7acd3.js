(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{152:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));var r=n(2),o=(n(0),n(178));const a={id:"createFormContext",title:"Using createFormContext()",sidebar_label:"Using createFormContext()"},i={id:"createFormContext",title:"Using createFormContext()",description:"Yafl also exports a function called createFormContext which returns the usual components you need to build your forms:",source:"@site/docs/createFormContext.md",permalink:"/yafl/docs/createFormContext",sidebar_label:"Using createFormContext()",sidebar:"main",previous:{title:"Arrays and nested objects",permalink:"/yafl/docs/arrays-and-objects"},next:{title:"<Form />",permalink:"/yafl/docs/form"}},c=[{value:"<code>createFormContext()</code> use cases",id:"createformcontext-use-cases",children:[{value:"Type safety",id:"type-safety",children:[]},{value:"Nested forms",id:"nested-forms",children:[]}]},{value:"Limitations of createFormContext()",id:"limitations-of-createformcontext",children:[]},{value:"Gotchas",id:"gotchas",children:[]}],l={rightToc:c};function s({components:e,...t}){return Object(o.b)("wrapper",Object(r.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Yafl also exports a function called ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext")," which returns the usual components you need to build your forms:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-tsx"}),"const { \n  Form,\n  Field,\n  Section,\n  Repeat,\n  FormError,\n  useCommonValues,\n  useBranchValues,\n  useFormContext\n } = createFormContext<T>()\n")),Object(o.b)("h2",{id:"createformcontext-use-cases"},Object(o.b)("inlineCode",{parentName:"h2"},"createFormContext()")," use cases"),Object(o.b)("p",null,"There are two reasons you might want to use ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext()"),":"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"You are using TypeScript:")," When using TypeScript you may specify a type to the generic function which will give all the components returned from this function awareness of the type ",Object(o.b)("inlineCode",{parentName:"li"},"T")," that you supply. This will help ensure type safety across components at the cost of a few extra key strokes."),Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"You are creating nested forms:")," Creating nested forms where nesting context providers would interfere with one another and cause some strange behavior. Nested forms are a fairly rare use case however.")),Object(o.b)("h3",{id:"type-safety"},"Type safety"),Object(o.b)("p",null,"Yafl is built in TypeScript and type safety is a primary concern of ours. However using generics inline with JSX can be cumbersome and noisy. One way to get around this is to supply the generic type argument for your form earlier on so that all your components magically become type aware. This means that all your form components and hooks (i.e. ",Object(o.b)("inlineCode",{parentName:"p"},"<Form>"),", ",Object(o.b)("inlineCode",{parentName:"p"},"<Field>"),", ",Object(o.b)("inlineCode",{parentName:"p"},"useField()"),") will be aware of the generic type ",Object(o.b)("inlineCode",{parentName:"p"},"T")," you supplied when you called ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext()"),". Let's see an example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts",metastring:'title="src/TypedForm.tsx"',title:'"src/TypedForm.tsx"'}),"\ninterface Profile {\n  email: string;\n  fullname: string;\n}\n\nconst { Form, useField } = createFormContext<Profile>()\n\n<Form onSubmit={(formValue) => { /* formValue will be of type Profile */ }}>\n  ...\n</Form>\n\nconst [input, meta] = useField<string>()\n\ninput.value // is of type string\nmeta.formValue // is of type Profile\nmeta.setFormValue({ badValue: true }) // reports a type error\n")),Object(o.b)("p",null,"This also means TypeScript will not allow you to call ",Object(o.b)("inlineCode",{parentName:"p"},"setFormValue()")," with anything that does not conform to the ",Object(o.b)("inlineCode",{parentName:"p"},"Profile")," interface."),Object(o.b)("h3",{id:"nested-forms"},"Nested forms"),Object(o.b)("p",null,"The second use case for ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext()")," is to enable the creation of nested forms where you have a ",Object(o.b)("inlineCode",{parentName:"p"},"<Form>")," nested within another ",Object(o.b)("inlineCode",{parentName:"p"},"<Form>"),". Due to the way the React context implementation ensures that a context ",Object(o.b)("inlineCode",{parentName:"p"},"<Consumer>")," will always talk to its ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://reactjs.org/docs/context.html#contextconsumer"}),"closest")," ",Object(o.b)("inlineCode",{parentName:"p"},"<Provider>")," which can make for some weird interactions between components if you're trying to nest forms.  The best thing to do if you have this requirement is to create a new form context by using ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext()"),". This will ensure both of your ",Object(o.b)("inlineCode",{parentName:"p"},"Forms")," use different ",Object(o.b)("inlineCode",{parentName:"p"},"Providers")," and Yafl consumers (",Object(o.b)("inlineCode",{parentName:"p"},"<Field>"),", ",Object(o.b)("inlineCode",{parentName:"p"},"<Section>"),", ",Object(o.b)("inlineCode",{parentName:"p"},"useField"),", etc) only speak to their relevant ",Object(o.b)("inlineCode",{parentName:"p"},"<Form>")," provider."),Object(o.b)("h2",{id:"limitations-of-createformcontext"},"Limitations of createFormContext()"),Object(o.b)("p",null,"Unfortunately ",Object(o.b)("inlineCode",{parentName:"p"},"createFormContext<T>()")," will not tell you when you are incorrectly nesting ",Object(o.b)("inlineCode",{parentName:"p"},"Sections"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Fields")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Repeats")," - there simply is no way to do that in TypeScript. Similarly Yafl does not tell you when you've supplied an incorrect ",Object(o.b)("inlineCode",{parentName:"p"},"name")," prop to one of these components either."),Object(o.b)("h2",{id:"gotchas"},"Gotchas"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Never call ",Object(o.b)("inlineCode",{parentName:"li"},"createFormContext")," in render - as with ",Object(o.b)("inlineCode",{parentName:"li"},"React.createContext")," always call ",Object(o.b)("inlineCode",{parentName:"li"},"createFormContext")," at the module level."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"createFormContext")," while similarly named to ",Object(o.b)("inlineCode",{parentName:"li"},"React.createContext")," does not accept an optional default value as an argument."),Object(o.b)("li",{parentName:"ul"},"We've noticed that the ",Object(o.b)("inlineCode",{parentName:"li"},"useField")," hook can become awkward to use in conjunction with ",Object(o.b)("inlineCode",{parentName:"li"},"createFormContext")," because of the way the ",Object(o.b)("inlineCode",{parentName:"li"},"useField")," hook it is used within custom input components. The best way to get around this is to use a higher order function to spit out a version of your component with the concrete type baked in:")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-tsx"}),"function createFromComponents<F>() {\n  const { useField, ...api } = createFormContext<F>()\n\n  function TextInput<T>(props: T) {\n    const [input, meta] = useField<T>()\n\n    ...\n\n    return <input {...input} >\n  }\n\n  return {\n    ...api,\n    useField,\n    TextInput,\n  }\n}\n\n")))}s.isMDXComponent=!0},178:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return d}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),p=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},m=function(e){var t=p(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(n),b=r,d=m["".concat(i,".").concat(b)]||m[b]||u[b]||a;return n?o.a.createElement(d,c(c({ref:t},s),{},{components:n})):o.a.createElement(d,c({ref:t},s))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=b;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);